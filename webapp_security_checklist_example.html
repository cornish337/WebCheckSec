<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Web App Security Checklist — Category/Subtask View (v8.1-importable)</title>
<style>
:root{--bg:#0b0f14;--fg:#e8f0ff;--muted:#9fb0c3;--card:#121822;--border:#1f2a37;--accent:#5fb3ff;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444;}
*{box-sizing:border-box;}
body{background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;}
header{padding:16px 18px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
h1{font-size:1.25rem;margin:0;}
.pill{background:#0f1722;border:1px solid var(--border);padding:6px 10px;border-radius:999px;color:var(--muted);}
main{max-width:1200px;margin:0 auto;padding:18px;}
.toolbar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:14px;align-items:center;}
.toolbar input,.toolbar select,.toolbar button,label.button{background:#0e1622;color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:10px 12px;cursor:pointer;}
.grid{display:grid;gap:14px;grid-template-columns:repeat(auto-fill,minmax(420px,1fr));}
.card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;}
.card .top{display:flex;align-items:center;justify-content:space-between;gap:10px;cursor:pointer;}
.card.collapsed .card-content{display:none;}
.card .title{font-weight:700;font-size:1.05rem;}
.card .count{color:var(--muted);font-size:0.85rem;}
.subcat{margin-top:10px;padding-top:6px;border-top:1px dashed var(--border);}
.subcat h3{margin:6px 0 8px;font-size:0.95rem;color:#cfe4ff;}
.item{background:#0c1420;border:1px solid var(--border);border-radius:10px;padding:8px;margin-bottom:8px;}
.item-head{display:flex;align-items:center;gap:8px;}
.item-head input[type="checkbox"]{transform:scale(1.15);}
.item-title{flex:1;}
.item-meta{color:var(--muted);font-size:0.85rem;margin-top:4px;}
.tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px;}
.tag{font-size:12px;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:#0b1a2a;color:#b8cff0;cursor:pointer;}
.subtasks{margin-top:8px;padding-left:8px;border-left:2px solid #1e293b;}
.subtask{display:flex;align-items:center;gap:8px;margin:4px 0;}
.subtask input[type="checkbox"]{transform:scale(1.05);}
details summary{cursor:pointer;color:var(--accent);font-weight:600;margin-top:8px;}
textarea{width:100%;background:#0b111a;color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:8px 10px;margin-top:6px;}
footer{color:var(--muted);text-align:center;padding:16px;}
.small{font-size:12px;color:var(--muted);}
</style>
</head>
<body>
<header>
  <h1>Web App Security Checklist — Category/Subtask View</h1>
  <span class="pill" id="overall">0/0 checks completed</span>
  <span class="pill" id="catcount">0 categories</span>
  <span class="pill">Local-only • saves in your browser</span>
</header>
<main>
  <div class="toolbar">
    <input id="search" placeholder="Search categories, items, tags…"/>
    <select id="filter">
      <option value="all">All</option>
      <option value="open">Open</option>
      <option value="done">Completed</option>
    </select>
    <button id="save">Save (local)</button>
    <button id="exportJSON">Export JSON</button>
    <button id="exportCSV">Export CSV</button>
    <button id="reset">Reset (from file)</button>
    <label for="prefillFile" class="button">Import Prefill (CSV/JSON)</label>
    <input id="prefillFile" type="file" accept=".csv,.json" style="display:none"/>
  </div>
  <div class="small" style="margin-bottom:10px;">
    Tip: Import your <b>JSON</b> (full dataset) or a <b>CSV</b> with headers: 
    <code>Category, Sub Category, Item, Done, Subtask, Subtask Done, ASVS, Description, Tools, Links, Applicability, Sources, Tags</code>.
  </div>
  <div id="grid" class="grid"></div>
  <p>Each card groups <b>Category → Sub Category → Items</b>. Each item has a checkbox and optional subtasks (also checkable). Click a tag to filter similar tests. Edits persist locally.</p>
</main>
<footer>Built for offline use. Export JSON/CSV to share with teammates.</footer>

<script>
const STORAGE_KEY = "was_category_subtask_v8_1";
const rawData = typeof __RAW__ !== 'undefined' ? __RAW__ : [];

function $(s){return document.querySelector(s);}
function el(t,p={},...k){const n=document.createElement(t);Object.assign(n,p);k.forEach(x=>n.append(x));return n;}
function load(){try{const s=localStorage.getItem(STORAGE_KEY);const p=s?JSON.parse(s):rawData;return Array.isArray(p)?p:rawData;}catch(e){return rawData;}}
function save(d){localStorage.setItem(STORAGE_KEY,JSON.stringify(d));}

function csvToObjects(text){
  const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
  if(!lines.length) return [];
  const header = lines[0].split(/,(?=(?:[^"]*\"[^"]*\")*[^"]*$)/).map(h=>h.replace(/^"|"$/g,"").trim());
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const cols = lines[i].split(/,(?=(?:[^"]*\"[^"]*\")*[^"]*$)/).map(c=>c.replace(/^"|"$/g,""));
    const obj = {};
    header.forEach((h,idx)=>{ obj[h] = cols[idx] !== undefined ? cols[idx] : ""; });
    rows.push(obj);
  }
  return rows;
}

// Create or find category/subcategory/item by names
function ensureCategory(data, catName){
  const key = (catName||"").trim();
  if(!key) return null;
  let idx = data.findIndex(c => (c.category||"").toLowerCase() === key.toLowerCase());
  if(idx === -1){
    data.push({ category: key, subcats: [] });
    idx = data.length - 1;
  }
  return data[idx];
}
function ensureSubcat(cat, subName){
  const key = (subName||"(General)").trim() || "(General)";
  cat.subcats = cat.subcats || [];
  let idx = cat.subcats.findIndex(sc => (sc.name||"").toLowerCase() === key.toLowerCase());
  if(idx === -1){
    cat.subcats.push({ name: key, items: [] });
    idx = cat.subcats.length - 1;
  }
  return cat.subcats[idx];
}
function ensureItem(subcat, itemTitle){
  const key = (itemTitle||"(no title)").trim() || "(no title)";
  subcat.items = subcat.items || [];
  let idx = subcat.items.findIndex(it => (it.title||"").toLowerCase() === key.toLowerCase());
  if(idx === -1){
    subcat.items.push({ title: key, done:false, asvs:"", desc:"", tools:"", links:"", applic:"", sources:"", tags:[], subtasks:[] });
    idx = subcat.items.length - 1;
  }
  return subcat.items[idx];
}

function mergePrefillRows(rows){
  rows.forEach(p => {
    const cat = ensureCategory(data, p["Category"]);
    if(!cat) return;
    const sc  = ensureSubcat(cat, p["Sub Category"]);
    const it  = ensureItem(sc, p["Item"]);

    // booleans
    const done = (p["Done"]||"").toString().trim().toLowerCase();
    if(done==="true"||done==="1"||done==="yes") it.done = true;

    // subtasks
    const stText = (p["Subtask"]||"").trim();
    const stDone = (p["Subtask Done"]||"").toString().trim().toLowerCase();
    if(stText){
      it.subtasks = it.subtasks || [];
      const exists = it.subtasks.find(s => (s.text||"") === stText);
      if(!exists) it.subtasks.push({text: stText, done: (stDone==="true"||stDone==="1"||stDone==="yes")});
    }

    // merge fields
    if(p["ASVS"]) it.asvs = it.asvs ? (it.asvs + "\n" + p["ASVS"]) : p["ASVS"];
    if(p["Description"]) it.desc = it.desc ? (it.desc + "\n\n" + p["Description"]) : p["Description"];
    if(p["Tools"]) it.tools = it.tools ? (it.tools + "\n\n" + p["Tools"]) : p["Tools"];
    if(p["Links"]) it.links = it.links ? (it.links + "\n\n" + p["Links"]) : p["Links"];
    if(p["Applicability"]) it.applic = it.applic ? (it.applic + "\n\n" + p["Applicability"]) : p["Applicability"];
    if(p["Sources"]) it.sources = it.sources ? (it.sources + "\n\n" + p["Sources"]) : p["Sources"];

    if(p["Tags"]){
      const parts = p["Tags"].split(/[;,\s]+/).map(x=>x.trim()).filter(Boolean);
      it.tags = Array.from(new Set([...(it.tags||[]), ...parts]));
    }
  });
  save(data); render();
}

function toCSV(data){
  const rows=[["Category","Sub Category","Item","Done","Subtask","Subtask Done","ASVS","Description","Tools","Links","Applicability","Sources","Tags"]];
  data.forEach(cat=>{
    (cat.subcats||[]).forEach(sc=>{
      (sc.items||[]).forEach(it=>{
        const base=[cat.category, sc.name, it.title, it.done?"TRUE":"FALSE", "", "", it.asvs||"", it.desc||"", it.tools||"", it.links||"", it.applic||"", it.sources||"", (it.tags||[]).join(" ")];
        if (Array.isArray(it.subtasks)&&it.subtasks.length){
          it.subtasks.forEach(st=>{
            rows.push(base.slice(0,4).concat([st.text, st.done?"TRUE":"FALSE"]).concat(base.slice(6)));
          });
        } else {
          rows.push(base);
        }
      });
    });
  });
  return rows.map(r => r.map(x => '"' + String(x || "").replaceAll('"', '""') + '"').join(',')).join('\n');
}

let data = load();
let tagFilter = "";

function render(){
  const q=$("#search").value.toLowerCase().trim();
  const f=$("#filter").value;
  const grid=$("#grid"); grid.innerHTML="";
  let total=0, done=0, catsShown=0;

  data.forEach(cat=>{
    let catTotal=0, catDone=0;
    const card=el("div",{className:"card"});
    const catCheckbox = el("input", {type: "checkbox"});
    catCheckbox.addEventListener("change", () => {
        (cat.subcats||[]).forEach(sc => {
            (sc.items||[]).forEach(it => {
                it.done = catCheckbox.checked;
            });
        });
        updateCounts();
    });
    const top=el("div",{className:"top"},
      catCheckbox,
      el("div",{className:"title"},cat.category||"(no category)"),
      el("div",{className:"count"},"0/0")
    );
    top.addEventListener("click", (e) => {
        if (e.target.type !== 'checkbox') {
            card.classList.toggle("collapsed");
        }
    });

    const contentWrapper = el("div", {className: "card-content"});

    (cat.subcats||[]).forEach(sc=>{
      const sec=el("div",{className:"subcat"});
      const subcatCheckbox = el("input", {type: "checkbox"});
      subcatCheckbox.addEventListener("change", () => {
          (sc.items||[]).forEach(it => {
              it.done = subcatCheckbox.checked;
          });
          updateCounts();
      });
      const h3 = el("h3",{}, subcatCheckbox, sc.name||"(General)");
      sec.append(h3);

      (sc.items||[]).forEach(it=>{
        const hay=( (cat.category||"")+" "+(sc.name||"")+" "+(it.title||"")+" "+(it.tags||[]).join(" ")+" "+(it.asvs||"") ).toLowerCase();
        if(q && !hay.includes(q)) return;
        if(tagFilter && !(it.tags||[]).includes(tagFilter)) return;

        const row=el("div",{className:"item"});
        const head=el("div",{className:"item-head"});
        const cb=el("input",{type:"checkbox",checked:!!it.done});
        cb.addEventListener("change",()=>{it.done=cb.checked; updateCounts();});
        head.append(cb,el("div",{className:"item-title"},it.title||"(no title)"));
        row.append(head);

        // tags
        const tags=el("div",{className:"tags"});
        (it.tags||[]).forEach(t=>{
          const pill=el("span",{className:"tag"},t);
          pill.addEventListener("click",()=>{tagFilter=(tagFilter===t)?"":t; render();});
          tags.append(pill);
        });
        if((it.tags||[]).length) row.append(tags);

        // subtasks
        if(Array.isArray(it.subtasks) && it.subtasks.length){
          const stwrap=el("div",{className:"subtasks"});
          it.subtasks.forEach(st=>{
            const srow=el("div",{className:"subtask"});
            const scb=el("input",{type:"checkbox",checked:!!st.done});
            scb.addEventListener("change",()=>{st.done=scb.checked; updateCounts();});
            srow.append(scb,el("div",{},st.text));
            stwrap.append(srow);
          });
          row.append(stwrap);
        }

        // expandable details for meta
        const det=el("details",{});
        det.append(el("summary",{},"Details"));
        const meta=[
          ["ASVS",it.asvs||""],
          ["Description",it.desc||""],
          ["Tools",it.tools||""],
          ["Links",it.links||""],
          ["Applicability / N/A",it.applic||""],
          ["Sources",it.sources||""]
        ];
        meta.forEach(([label,val])=>{
          const ta=el("textarea",{}); ta.value=val;
          ta.addEventListener("input",()=>{ if(label==="ASVS") it.asvs=ta.value; else if(label==="Description") it.desc=ta.value; else if(label==="Tools") it.tools=ta.value; else if(label==="Links") it.links=ta.value; else if(label==="Applicability / N/A") it.applic=ta.value; else if(label==="Sources") it.sources=ta.value; save(data); });
          det.append(el("div",{className:"item-meta"},label), ta);
        });
        row.append(det);

        sec.append(row);
        catTotal += 1;
        if(it.done) catDone += 1;
        total += 1;
        if(it.done) done += 1;
      });

      if(sec.children.length>1) contentWrapper.append(sec);
    });

    if (contentWrapper.children.length > 0) {
      top.lastChild.textContent = `${catDone}/${catTotal}`;
      card.append(top, contentWrapper);
      grid.append(card);
      catsShown += 1;
    }
  });

  $("#overall").textContent = `${done}/${total} checks completed`;
  $("#catcount").textContent = `${catsShown} categories`;
}

function updateCounts(){ save(data); render(); }

$("#search").addEventListener("input",render);
$("#filter").addEventListener("change",render);
$("#save").addEventListener("click",()=>save(data));
$("#reset").addEventListener("click",()=>{ data=JSON.parse(JSON.stringify(rawData)); save(data); render(); });
$("#exportJSON").addEventListener("click",()=>{
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([JSON.stringify(data,null,2)],{type:"application/json"}));
  a.download="webapp_category_subtasks.json"; a.click();
});
$("#exportCSV").addEventListener("click",()=>{
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([toCSV(data)],{type:"text/csv"}));
  a.download="webapp_category_subtasks.csv"; a.click();
});

function transformImportedData(importedData) {
  const newData = [];
  importedData.forEach(cat => {
    const newCat = {
      category: cat.category,
      subcats: []
    };

    (cat.items || []).forEach(item => {
      const asvs_parts = (item.asvs || "General").split('.');
      const subCatName = asvs_parts.length > 1 ? `ASVS ${asvs_parts[0]}.${asvs_parts[1]}` : "General";
      
      let subcat = newCat.subcats.find(sc => sc.name === subCatName);
      if (!subcat) {
        subcat = { name: subCatName, items: [] };
        newCat.subcats.push(subcat);
      }

      const newItem = {
        title: item.title || '(no title)',
        done: false,
        asvs: item.asvs || '',
        desc: item.simple_desc || '',
        tools: '',
        links: item.references || '',
        applic: item.applicability || '',
        sources: Array.isArray(item.sources) ? item.sources.join('\n') : (item.sources || ''),
        tags: [],
        subtasks: []
      };

      if (item.how_to_test) {
          if (typeof item.how_to_test === 'object') {
              let tools_text = [];
              if(item.how_to_test.manual) tools_text.push("Manual:\n" + item.how_to_test.manual.join('\n'));
              if(item.how_to_test.tools) tools_text.push("Tools:\n" + item.how_to_test.tools.map(t => `${t.name}: ${t.use}`).join('\n'));
              if(item.how_to_test.combo_packs) tools_text.push("Combo Packs:\n" + item.how_to_test.combo_packs.join('\n'));
              newItem.tools = tools_text.join('\n\n');
          } else {
              newItem.tools = item.how_to_test;
          }
      }
      
      let extra_desc = [];
      if(item.grouping) extra_desc.push("Grouping:\n" + (typeof item.grouping === 'object' ? JSON.stringify(item.grouping, null, 2) : item.grouping));
      if(item.cross_method_example) extra_desc.push("Cross-Methodology Example:\n" + item.cross_method_example);
      if(item.caveats) extra_desc.push("Caveats:\n" + (Array.isArray(item.caveats) ? item.caveats.join('\n') : item.caveats));
      
      if(extra_desc.length > 0) {
          newItem.desc += "\n\n" + extra_desc.join("\n\n");
      }

      subcat.items.push(newItem);
    });

    newData.push(newCat);
  });
  return newData;
}

$("#prefillFile").addEventListener("change", (ev) => {
  const f = ev.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const name = (f.name||'').toLowerCase();
      const text = e.target.result;

      if (name.endsWith(".json")) {
        const obj = JSON.parse(text);
        if (Array.isArray(obj) && obj.length && typeof obj[0] === "object" && ("category" in obj[0]) && ("items" in obj[0]) && !("subcats" in obj[0])) {
            data = transformImportedData(obj);
            save(data);
            render();
        } else if (Array.isArray(obj) && obj.length && typeof obj[0]==="object" && ("category" in obj[0])) {
          // Treat as a full dataset - replace
          data = obj;
          save(data);
          render();
        } else if (Array.isArray(obj)) {
          // Treat as prefill list of rows
          mergePrefillRows(obj);
        } else {
          alert("JSON must be an array (either full dataset of categories/items, or rows with CSV-like keys).");
        }
      } else {
        const rows = csvToObjects(text);
        mergePrefillRows(rows);
      }
    } catch (err) {
      alert("Failed to import: " + err.message);
    }
  };
  reader.readAsText(f);
});

render();
</script>
</body>
</html>